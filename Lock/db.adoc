== Lock in DB
[%hardbreaks]

== 잠금
[%hardbreaks]
직렬성을 보장하기 위한 방법으로 데이터 객체들이 상호배타적으로 접근 가능하게 하는 것
트랜잭션에 대한 데이터에 액세스했을 때 트랜잭션이 해당 객체를 수정하지 못하도록 하는 것
다중 사용자 환경에서 데이터의 일관성과 무결성을 보장하기 위해 순차적 진행을 보장하기 위한 것

트랜잭션 스케줄링, 직렬화 - 락으로 구현 됨

내가 데이터를 보고 있으면 고치지 마라!

== 페이지 잠금
[%hardbreaks]
데이터베이스에서 사용하는 페이지 단위로 락을 설정하는 방식
하나의 페이지는 여러 개의 레코드(데이터 행)를 포함 가능.
페이지 락은 주로 인덱스 구조나 데이터 파일에서 사용 됨.

ex. 대통령 화장실 갈 때

== 레코드 잠금
[%hardbreaks]
데이터베이스에서 개별 레코드(데이터 행) 단위로 락을 설정하는 방식
한 트랜잭션이 특정 레코드를 수정하는 동안 다른 트랜잭션이 해당 레코드에 접근하지 못하도록 함

ex. 민간인 화장실 갈 때 (자신이 잠금)

== 파일 잠금
파일 잠금은 파일 전체를 대상으로 락을 설정하는 방식
파일 시스템이나 데이터베이스의 큰 파일 단위로 작업할 때 사용


== 기록 판독 충돌 (WR 충돌)
[%hardbreaks]
레인지, 레코드에 대해 발생
레인지 - 페이지를 잠궈야 함
레코드 - 레코드를 잠궈야 함

대부분의 DB는 레코드락, 페이지락 모두 유지

업데이트 도중 사용자가 읽게 되면 문제 발생

미완결 데이터 (트랜잭션이 종료되지 않은 데이터) 데이터를 읽을 경우
일관성, 지속성이 없다.

== 판독 기록 충돌 (RW 충돌)
[%hardbreaks]
읽고있는 데이터에 대해 수정할 수 있는지
수정 전인지 수정 후인지 모름

반복 불가능한 작업을 수행하는 경우
객체 A의 값을 판독 중에 T2가 객체 A값을 변경하는 경우

ex) 송금 중에 입금한다.

커밋 된 것을 읽을 수 있느냐 못 읽게 하느냐

== 기록 기록 충돌 (WW 충돌)
[%hardbreaks]
두 사람이 동시에 쓰고있다면

커밋 중에 (미완결 데이터=트랜잭션에 참여 중인 데이터) 수정하려고 할 때

== 데드락
[%hardbreaks]
A트랜잭션이 1을 잠그고 B트랜잭션이 2를 잠그고 있을 때
A가 2, B가 1을 읽으려고 할 때 A, B 모두 못 읽는다.

논리적으로 막을 수 없음

== 데드락 Preventer
[%hardbreaks]
DB는 데드락 감시하는 역할 제공

MySQL, Oracle 다 됨

== 공유 잠금
잠궜어도 읽을 수는 있는 쓸 수는 없는 잠금

== 배타 잠금 (전용락)
[%hardbreaks]
잠그면 아무도 못 들어오게하는 잠금
읽을 수도 없고 쓸 수도 없는 잠금
[%hardbreaks]
ex) 화장실 - 동시에 두 사람이 들어올 수 없다
화장실 문 - 임계 구역
두 사람이 급해서 화장실에 들어왔다 - 경쟁 조건
배타적 잠금 구현 시 - 상호 배제 구현

업데이트하면 sql server는 전용락을 건다

배타적 락이 걸린 상태에서 롤백을 하면 락이 풀리고 즉시 읽거나 수정할 수 있게 된다.

트랜잭션 start 후 트랜잭션 select 하면 트랜잭션 개수는 1개로 실행중인 상태이고 공유락이 걸려있다.
읽을 수 있으니 성능에 문제 없음

공유락이 걸려있으면 배타락도 걸 수 있다.

update, delete, insert 실행 -> 배타락이 걸린다


== 낙관적 락
ex. git(작업 전에 별도의 락을 걸지 않음), svn(비관적락을 옵션으로 제공)

== 비관적 락
ex. notion(실시간 협업에서 블록 단위의 공유 잠금 적용)

== 트랜잭션 격리 수준


